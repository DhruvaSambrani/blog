<!doctype html><html xmlns=http://www.w3.org/1999/xhtml lang xml:lang><meta charset=utf-8><meta name=generator content="pandoc"><meta name=viewport content="width=device-width,initial-scale=1,user-scalable=yes"><meta name=author content="Dhruva Sambrani"><meta name=keywords content="diy,electronics"><title>Controlling devices by Voltage injection | Dhruva's Blog</title><link rel=stylesheet href=/blog/assets/css/pandoc-styles.css><link rel=stylesheet href=/blog/assets/css/styles.css><script data-external=1 src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js></script><div class=markdown-body><h1 id=controlling-devices-by-voltage-injection>Controlling devices by Voltage injection</h1><p>I have a friend in Ghent, <a href=https://20akshay00.github.io/>akshay</a>. He got me back onto electronics, which I got him onto in the first place. Strange times. So I bought an ESP32 (C6 variant, this is necessary).<p>I have a projector at home. Its a shitty chinese projector that can be controlled either by the buttons on it or the remote. How to control the projector with my phone? I can communicate with an esp either via Bluetooth or wifi, but then how to use the ESP32 to control the projector? We have two ways: either emulate the IR Remote or the buttons.<h1 id=emulating-the-ir-remote>Emulating the IR Remote</h1><p>This is actually pretty easy. Connect an IR Sensor and an IR Emitter to your ESP. Use <a href=https://github.com/Arduino-IRremote/Arduino-IRremote>IRRemote.h</a> and the arduino programming language (? Environment? I don‚Äôt exactly know what it really is actually), to write to serial what was last recorded by the IR Sensor. Most cheap remotes use the NEC protocol, and so did my remote. The buttons are mapped to address <code>0x0001</code> and command <code>0x00 - 0x0C</code> for the 14 buttons on the remote.<p>This actually works great with the Arduino Uno, but not so much with the esp, for unknown reasons. I also controlled cheap led strips with the same code, which at least worked, but had really poor range. I even tried to drive the led with a 5V source and a transistor, and while it makes it much better, the range is still bad for the strips. The projector however refused to react at all. Why? I don‚Äôt know.<h1 id=emulating-button-presses>Emulating button presses</h1><p>I could try troubleshooting this, but I felt it would be more fun to emulate the button presses instead. Obviously mechanically doing this is trivial if you had so many motors, but that‚Äôs not what I had in mind. There had to be a way to directly signal the projector MC to control it. So I carefully opened up the projector housing, which was unsurprisingly easy.<h2 id=first-observations>First Observations</h2><p>I had predicted that the wiring would be very simple. There would be a wire for each button, and the button would either pull down to ground (typically) or to Vcc (rarely). My ESP would just have to match it, which would be easy if it were &lt; 3.3V as I could directly drive it from the GPIOs, and if not would require a transistor to isolate the voltages.<p>This is what I saw when I opened it up.<figure><img src=./assets/images/2025-12-16_163200-1.jpg alt="Button daughter board connected to MC with a 5 wired cable"><figcaption aria-hidden=true>Button daughter board connected to MC with a 5 wired cable</figcaption></figure><p>First of all I was smart to not just yank the top shell, since there was a wire connecting the MC to the daughter board with the buttons. Carefully unplugging and unscrewing the board, we see:<h2 id=button-board>Button board</h2><figure><img src=./assets/images/2025-12-16_163200-2.jpg alt="Front View"><figcaption aria-hidden=true>Front View</figcaption></figure><figure><img src=./assets/images/2025-12-16_163200-3.jpg alt="Back View"><figcaption aria-hidden=true>Back View</figcaption></figure><p>As you can see, there are not enough wires (5) to match the buttons (9) for my assumption. Instead, we see pins marked <code>K0</code>, <code>K1</code>, <code>GND</code>, <code>R</code>, <code>G</code>. Now the <code>R</code> and <code>G</code> are probably the 2 colored LED, which you can confirm by tracing the traces too. Clearly K0 and K1 must carry the data of the buttons. Is it like the membrane buttons which are indexed by the X and Y to ID them? But even those need 8 pins for 16 buttons. Looking at the traces more carefully we see that K0 is connected to 8 of the buttons, with small resistors on the traces. Clearly, pressing the button will complete the circuit, engaging exactly one of these resistors (trace it and you‚Äôll see). Presumably then the MC sensor reads the resistance between K0 and ground to figure out which button is pressed. How does it do that? It sets some <code>Vcc</code> and has a large internal resistor <code>R0</code> before pin <code>K0</code>. When the circuit completes, the voltage at <code>K0</code> gets pulled down by the button, but not to 0, rather to a voltage given by:<p><span class="math display">\[V_i = V_{cc} \frac{R_i}{R_0 + R_i} \approx V_{cc} \frac{R_i}{R_0}\]</span><p>These values could be found by just turning on the projector and reading the voltages while pressing buttons. <code>Vcc</code> was around 1.85V, so I could safely continue with using the ESP.<p>All we need to do is emulate the same action.<p>The obvious way is to place a transistor in switch mode in parallel to each button, thus providing a secondary path for the current to flow, allowing either switch (original or transistor) to work as expected. But this will need finicky soldering to each button, and there would be no space for the button caps to sit. The alternative is to set the voltage by an analog write from the ESP to <code>K0</code>.<h2 id=pwm>PWM</h2><p>But the ESP32 C6 variant does not have an onboard DAC (I am reasonably sure about this, but I did see some sources claiming that it does have one), and can only PWM. I hoped that the PWM was by itself fast enough for the microcontroller‚Äôs inherent capacitance, but clearly that was not enough. I then tried to make an RC filter, but this failed too since I only had a 25uF electrolytic cap or a 100pF ceramic cap, and nothing in between. The 25uF was way too large and had a very long response time, and instead of instantly setting the voltage to 0, it would slowly go down to it, triggering all the other buttons in between. This was obviously not going to work. The 100pF cap was too small and I don‚Äôt think it actually did anything. I don‚Äôt have an oscilloscope, but I made a make-shift one with an arduino reading A0 and writing to a serial plotter. Obviously this did not have the time resolution necessary for the task, so it wasn‚Äôt clear why it didn‚Äôt work in spite of picking large R values ü§∑‚Äç‚ôÇÔ∏è.<h2 id=dac>DAC</h2><p>Searching online a little, the MCP4725 was a chip that supported I2C communications and did DAC. I ordered one off aliexpress and waited for a week. It came, I tested it. Since I had not soldered the pins yet, there were loose connections that initially made me think the chip didn‚Äôt work, but it actually worked very well. 200ms is a good delay for it to register as a single click.<p>And so there we had it! I could now control the projector with my phone by sending the esp commands. Except‚Ä¶<h1 id=audio>Audio</h1><p>Turns out there are no volume buttons on the projector. I don‚Äôt know why. Anyway, the music is output via an aux cable to some old Logitech speakers which have a potentiometer controlling the audio. Presumably I can emulate the volume level by setting the voltage on the output of the potentiometer? So I opened it up to see what voltage the potentiometer was being run on. And I got 0V. Strange. What was stranger was as I was testing for continuity, I touched some pin by mistage and the speakers gave a sound. There should be no reason for a volume control to give a sound right? Thats when I thought a bit more and realised the aux cable was directly coming into the control. Asking AI what this could mean, I realised that the audio signal itself was manipulated by the resistor. By acting as a divider, the amplitude of the audio signal was damped, which obviously could not be controlled by setting voltage. So turns out I have to actually emulate a variable resistance, not a variable voltage. This can be done in one of the following ways:<ol type=1><li>A DigiPot chip (MCP4131): This is the resistor brother of a MCP4725. In fact one could build a poor DAC from a DigiPot, but not the other way around.<li>A transistor in its active phase: This is super finicky, and the transistor has to be very carefully tuned to prevent it from going out of the linear response region, and is hard to control.<li>A Resistive optoisolator: Also called a Vactrol, this uses an Light dependant resistor (Light sensor) controlled by an LED. By setting the LED brightness, one can set the LDR resistance, thus allowing for signal damping. This I could beild with components I have, but is finicky.</ol><p>The final issue with audio control is that I cannot easily run both controls in parallel. They would both perform a dampings, causing 2 controls rather than one. The only way is to desolder the pot, and connect it to the ESP, which would have to do some logic to keep both controls in sync. Maybe I could replace it with a rotary encoder, and thus only have a ‚Äúvolume up/down‚Äù control rather than setting a specific volume. Of course, running a motor to physically rotate the pot is always an option üôÉ.<p>Considering that I will anyway set the volume from the source device, I felt I would not gain much from this. But then again, I don‚Äôt see what I‚Äôm gaining from using my phone rather than the remote either üòÖ.<p>That‚Äôs it for today.</div><div class="markdown-body tags"><a href=/blog/tags.html#diy>#diy<a>, <a href=/blog/tags.html#electronics>#electronics<a></div><footer><a class=footer-button id=nav1 href=/blog/tags.html>Tags</a>
<img alt="Creative Commons License" style=border-width:0 src=https://i.creativecommons.org/l/by-nc/4.0/88x31.png>
<a id=fivetwelvea href=https://512kb.club><img id=fivetwelve alt="a proud member of the green team of 512KB club"></a>
<a class=footer-button id=nav2 href=/blog/contents.html>Contents</a></footer>